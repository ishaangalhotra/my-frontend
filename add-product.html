<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Product Management - QuickLocal</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --primary: #6366f1;
            --primary-dark: #4338ca;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --text-primary: #0f172a;
            --text-secondary: #475569;
            --bg-primary: #ffffff;
            --bg-secondary: #f8fafc;
            --border: #e2e8f0;
            --radius: 0.5rem;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-secondary);
            color: var(--text-primary);
            line-height: 1.6;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 2rem;
        }

        .header {
            text-align: center;
            margin-bottom: 2rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }
        
        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            background: var(--bg-primary);
            border-radius: var(--radius);
            padding: 0.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow);
        }
        
        .tab-btn {
            flex: 1;
            padding: 0.875rem 1.5rem;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: 600;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .tab-btn.active {
            background: var(--primary);
            color: white;
            box-shadow: var(--shadow);
        }
        
        .tab-btn:hover:not(.active) {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            background: linear-gradient(135deg, var(--primary), #8b5cf6);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 0.5rem;
        }

        .header p {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .form-card {
            background: var(--bg-primary);
            border-radius: var(--radius);
            padding: 2rem;
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        .form-input,
        .form-select,
        .form-textarea {
            width: 100%;
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            font-size: 1rem;
            transition: all 0.2s;
            background: var(--bg-primary);
        }

        .form-input:focus,
        .form-select:focus,
        .form-textarea:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .form-textarea {
            min-height: 120px;
            resize: vertical;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
        }

        .file-upload {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-upload input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-upload-btn {
            display: block;
            width: 100%;
            padding: 0.75rem;
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            background: var(--bg-secondary);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-upload-btn:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .image-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .image-preview-item {
            position: relative;
            border-radius: var(--radius);
            overflow: hidden;
            background: var(--bg-secondary);
            aspect-ratio: 1;
        }

        .image-preview-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .image-remove {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            background: var(--error);
            color: white;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: var(--radius);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            text-decoration: none;
            font-size: 1rem;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 2px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--border);
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .alert {
            padding: 1rem;
            border-radius: var(--radius);
            margin-bottom: 1rem;
            font-weight: 500;
            display: none;
        }

        .alert-success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .alert-error {
            background: rgba(239, 68, 68, 0.1);
            color: var(--error);
            border: 1px solid rgba(239, 68, 68, 0.2);
        }

        .debug-info {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: var(--radius);
            padding: 1rem;
            margin-top: 1rem;
            font-family: monospace;
            font-size: 0.875rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 2rem;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid var(--border);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .form-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .category-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.5rem;
        }

        .category-item {
            padding: 0.75rem;
            border: 2px solid var(--border);
            border-radius: var(--radius);
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg-primary);
        }

        .category-item:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .category-item.selected {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
        }

        /* Products Management Styles */
        .products-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .search-filters {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .search-input {
            min-width: 300px;
        }
        
        .stats-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }
        
        .stat-card {
            background: var(--bg-primary);
            padding: 1.5rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            text-align: center;
        }
        
        .stat-card .stat-icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .stat-card .stat-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary);
        }
        
        .stat-card .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
        
        .products-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 1.5rem;
        }
        
        .product-card {
            background: var(--bg-primary);
            border-radius: var(--radius);
            padding: 1.5rem;
            box-shadow: var(--shadow);
            transition: transform 0.2s;
        }
        
        .product-card:hover {
            transform: translateY(-2px);
        }
        
        .product-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
        }
        
        .product-info h3 {
            margin: 0 0 0.5rem 0;
            color: var(--text-primary);
        }
        
        .product-category {
            background: var(--primary);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .product-details {
            margin: 1rem 0;
        }
        
        .product-detail {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }
        
        .product-detail .label {
            color: var(--text-secondary);
        }
        
        .product-detail .value {
            font-weight: 600;
        }
        
        .product-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }
        
        .btn-danger {
            background: var(--error);
            color: white;
        }
        
        .btn-danger:hover {
            background: #dc2626;
        }
        
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        
        .btn-warning:hover {
            background: #d97706;
        }
        
        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 0.5rem;
            margin-top: 2rem;
        }
        
        .pagination button {
            padding: 0.5rem 1rem;
            border: 1px solid var(--border);
            background: var(--bg-primary);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .pagination button:hover {
            background: var(--primary);
            color: white;
        }
        
        .pagination button.active {
            background: var(--primary);
            color: white;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: var(--text-secondary);
        }
        
        .empty-state i {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
        }
        
        .modal-content {
            background-color: var(--bg-primary);
            margin: 5% auto;
            padding: 2rem;
            border-radius: var(--radius);
            width: 90%;
            max-width: 500px;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-secondary);
        }
        
        .modal-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
            margin-top: 2rem;
        }
        
        @media (max-width: 768px) {
            .container { padding: 1rem; }
            .form-row { grid-template-columns: 1fr; }
            .form-actions { flex-direction: column; }
            .btn { justify-content: center; }
            .products-header { flex-direction: column; align-items: stretch; }
            .search-filters { flex-direction: column; }
            .search-input { min-width: auto; }
            .products-grid { grid-template-columns: 1fr; }
            .tab-navigation { flex-direction: column; }
            .modal-content { width: 95%; margin: 10% auto; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-cogs"></i> Product Management</h1>
            <p>Manage your QuickLocal marketplace products</p>
        </div>

        <div class="tab-navigation">
            <button class="tab-btn active" data-tab="add-product">
                <i class="fas fa-plus"></i> Add Product
            </button>
            <button class="tab-btn" data-tab="manage-products">
                <i class="fas fa-list"></i> Manage Products
            </button>
            <button class="tab-btn" data-tab="statistics">
                <i class="fas fa-chart-bar"></i> Statistics
            </button>
        </div>

        <div id="alertContainer"></div>

        <div id="add-product" class="tab-content active">
            <form id="productForm" class="form-card">
            <div class="form-group">
                <label class="form-label" for="name">
                    <i class="fas fa-tag"></i> Product Name *
                </label>
                <input type="text" id="name" class="form-input" placeholder="Enter product name" required>
            </div>

            <div class="form-group">
                <label class="form-label" for="description">
                    <i class="fas fa-align-left"></i> Description *
                </label>
                <textarea id="description" class="form-textarea" placeholder="Describe your product in detail" required></textarea>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label" for="price">
                        <i class="fas fa-rupee-sign"></i> Price (â‚¹) *
                    </label>
                    <input type="number" id="price" class="form-input" placeholder="0.00" step="0.01" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="originalPrice">
                        <i class="fas fa-tags"></i> Original Price (â‚¹)
                    </label>
                    <input type="number" id="originalPrice" class="form-input" placeholder="0.00" step="0.01">
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">
                    <i class="fas fa-list"></i> Category *
                </label>
                <div class="category-grid" id="categoryGrid">
                    <p>Loading categories...</p>
                </div>
                <input type="hidden" id="category" required>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label" for="stock">
                        <i class="fas fa-boxes"></i> Stock Quantity *
                    </label>
                    <input type="number" id="stock" class="form-input" placeholder="0" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="unit">
                        <i class="fas fa-balance-scale"></i> Unit
                    </label>
                    <select id="unit" class="form-select">
                        <option value="piece">Piece</option>
                        <option value="kg">Kilogram</option>
                        <option value="gram">Gram</option>
                        <option value="liter">Liter</option>
                        <option value="ml">Milliliter</option>
                        <option value="pack">Pack</option>
                        <option value="box">Box</option>
                        <option value="dozen">Dozen</option>
                    </select>
                </div>
            </div>

            <div class="form-row">
                <div class="form-group">
                    <label class="form-label" for="brand">
                        <i class="fas fa-certificate"></i> Brand
                    </label>
                    <input type="text" id="brand" class="form-input" placeholder="Brand name">
                </div>
                <div class="form-group">
                    <label class="form-label" for="weight">
                        <i class="fas fa-weight"></i> Weight (kg)
                    </label>
                    <input type="number" id="weight" class="form-input" placeholder="0.0" step="0.01">
                </div>
            </div>

            <div class="form-group">
                <label class="form-label" for="tags">
                    <i class="fas fa-hashtag"></i> Tags
                </label>
                <input type="text" id="tags" class="form-input" placeholder="organic, fresh, local (comma separated)">
            </div>

            <div class="form-group">
                <label class="form-label">
                    <i class="fas fa-images"></i> Product Images
                </label>
                <div class="file-upload">
                    <input type="file" id="images" multiple accept="image/*">
                    <label for="images" class="file-upload-btn">
                        <i class="fas fa-cloud-upload-alt"></i> Click to upload images (max 5)
                    </label>
                </div>
                <div id="imagePreview" class="image-preview"></div>
            </div>

            <div class="form-actions">
                <button type="button" class="btn btn-secondary" onclick="resetForm()">
                    <i class="fas fa-times"></i> Reset
                </button>
                <button type="submit" class="btn btn-primary">
                    <i class="fas fa-plus"></i> Add Product
                </button>
            </div>
            </form>

            <div id="loading" class="loading">
                <div class="spinner"></div>
                <p>Adding your product to QuickLocal...</p>
            </div>
        </div>

        <div id="manage-products" class="tab-content">
            <div class="products-header">
                <div class="search-filters">
                    <input type="text" id="productSearch" class="form-input search-input" placeholder="Search products...">
                    <select id="categoryFilter" class="form-select">
                        <option value="">All Categories</option>
                    </select>
                    <select id="stockFilter" class="form-select">
                        <option value="">All Stock Status</option>
                        <option value="in-stock">In Stock</option>
                        <option value="low-stock">Low Stock (â‰¤10)</option>
                        <option value="out-of-stock">Out of Stock</option>
                    </select>
                </div>
                <button id="refreshProducts" class="btn btn-secondary">
                    <i class="fas fa-sync"></i> Refresh
                </button>
            </div>

            <div id="productsGrid" class="products-grid">
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Loading products...</p>
                </div>
            </div>

            <div id="productsPagination" class="pagination"></div>
        </div>

        <div id="statistics" class="tab-content">
            <div class="stats-cards">
                <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-box"></i></div>
                    <div class="stat-value" id="totalProducts">0</div>
                    <div class="stat-label">Total Products</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-tags"></i></div>
                    <div class="stat-value" id="totalCategories">0</div>
                    <div class="stat-label">Categories</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-exclamation-triangle"></i></div>
                    <div class="stat-value" id="lowStockProducts">0</div>
                    <div class="stat-label">Low Stock</div>
                </div>
                <div class="stat-card">
                    <div class="stat-icon"><i class="fas fa-times-circle"></i></div>
                    <div class="stat-value" id="outOfStockProducts">0</div>
                    <div class="stat-label">Out of Stock</div>
                </div>
            </div>

            <div class="form-card">
                <h3>Category Breakdown</h3>
                <div id="categoryBreakdown">
                    <p>Loading category statistics...</p>
                </div>
            </div>
        </div>

        <div id="confirmModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 id="modalTitle">Confirm Action</h3>
                    <button class="modal-close">&times;</button>
                </div>
                <p id="modalMessage">Are you sure you want to perform this action?</p>
                <div class="modal-actions">
                    <button id="modalCancel" class="btn btn-secondary">Cancel</button>
                    <button id="modalConfirm" class="btn btn-danger">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    <script src="https://ecommerce-backend-mlik.onrender.com/hybrid-auth-client.js"></script>
    <script>
        const API_BASE_URL = 'https://ecommerce-backend-mlik.onrender.com/api/v1';
        
        let selectedCategory = '';
        let selectedFiles = [];
        let allProducts = [];
        let filteredProducts = [];
        let currentPage = 1;
        const productsPerPage = 12;
        let allCategories = [];

        document.addEventListener('DOMContentLoaded', function() {
            // Wait for HybridAuthClient to be ready
            const checkAuthReady = setInterval(() => {
                if (window.HybridAuthClient) {
                    clearInterval(checkAuthReady);
                    console.log('Auth Client Ready. Initializing page.');
                    
                    // Check if logged in -- DEV HACK: Login check temporarily disabled
                    // if (!window.HybridAuthClient.getCurrentUser()) {
                    //     showAlert('You must be logged in to manage products. Redirecting...', 'error');
                    //     setTimeout(() => {
                    //         window.location.href = `login.html?redirect=${encodeURIComponent(window.location.href)}`;
                    //     }, 2000);
                    // } else {
                         
                         // User is logged in, proceed with loading
                        loadCategories();
                        setupImageUpload();
                        setupForm();
                        setupTabs();
                        setupModal();
                        setupProductManagement();
                    
                    // } // End of disabled DEV HACK
                }
            }, 100);
        });

        // Tab Management
        function setupTabs() {
            const tabBtns = document.querySelectorAll('.tab-btn');
            const tabContents = document.querySelectorAll('.tab-content');

            tabBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetTab = btn.getAttribute('data-tab');

                    tabBtns.forEach(b => b.classList.remove('active'));
                    tabContents.forEach(c => c.classList.remove('active'));

                    btn.classList.add('active');
                    document.getElementById(targetTab).classList.add('active');

                    if (targetTab === 'manage-products') {
                        loadAllProducts();
                    } else if (targetTab === 'statistics') {
                        loadStatistics();
                    }
                });
            });
        }

        // Product Management Setup
        function setupProductManagement() {
            document.getElementById('productSearch').addEventListener('input', debounce(filterProducts, 300));
            document.getElementById('categoryFilter').addEventListener('change', filterProducts);
            document.getElementById('stockFilter').addEventListener('change', filterProducts);
            document.getElementById('refreshProducts').addEventListener('click', loadAllProducts);
        }

        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        async function loadCategories() {
            console.log('Fetching real categories from the API...');
            const categoryGrid = document.getElementById('categoryGrid');
            const categoryFilter = document.getElementById('categoryFilter');
            
            try {
                // FIXED: Use the HybridAuthClient to make the request
                if (!window.HybridAuthClient) {
                    throw new Error('Auth client not loaded');
                }
                
                const response = await window.HybridAuthClient.apiCall('categories?limit=50', {
                    method: 'GET'
                });
                
                const result = await response.json();

                if (result.success && result.data.categories.length > 0) {
                    const categories = result.data.categories;
                    allCategories = categories;
                    
                    const categoryIcons = {
                        'Electronics': 'fas fa-mobile-alt',
                        'Clothing': 'fas fa-tshirt',
                        'Home & Garden': 'fas fa-home',
                        'Sports & Fitness': 'fas fa-futbol',
                        'Bedsheets': 'fas fa-bed',
                        'Sofa': 'fas fa-couch',
                        'Fruits': 'fas fa-apple-alt',
                        'Vegetables': 'fas fa-carrot',
                        'Dairy': 'fas fa-glass-whiskey',
                        'Bakery': 'fas fa-bread-slice',
                        'Meat & Fish': 'fas fa-fish',
                        'Groceries': 'fas fa-shopping-basket'
                    };

                    categoryGrid.innerHTML = categories.map(category => `
                        <div class="category-item" data-category-id="${category._id}" data-category-name="${category.name}">
                            <i class="${categoryIcons[category.name] || 'fas fa-tag'}"></i><br>
                            ${category.name}
                        </div>
                    `).join('');

                    if (categoryFilter) {
                        categoryFilter.innerHTML = '<option value="">All Categories</option>' + 
                            categories.map(cat => `<option value="${cat._id}">${cat.name}</option>`).join('');
                    }

                    setupCategorySelection();
                } else {
                    categoryGrid.innerHTML = '<p>No categories found. Please add categories in the admin panel first.</p>';
                }
            } catch (error) {
                console.error('Failed to load categories:', error);
                categoryGrid.innerHTML = `<p class="alert alert-error" style="display: block; grid-column: 1 / -1;">Error loading categories: ${error.message}</p>`;
            }
        }

        async function loadAllProducts() {
            const productsGrid = document.getElementById('productsGrid');
            
            try {
                productsGrid.innerHTML = `
                    <div class="loading">
                        <div class="spinner"></div>
                        <p>Loading products...</p>
                    </div>
                `;

                // FIXED: Use HybridAuthClient
                const response = await window.HybridAuthClient.apiCall('products?limit=1000', {
                    method: 'GET'
                });
                const result = await response.json();

                if (result.success && result.data) {
                    allProducts = Array.isArray(result.data) ? result.data : 
                                  result.data.products ? result.data.products : [];
                    filteredProducts = [...allProducts];
                    currentPage = 1;
                    renderProducts();
                } else {
                    productsGrid.innerHTML = `
                        <div class="empty-state">
                            <i class="fas fa-box-open"></i>
                            <h3>No products found</h3>
                            <p>Add some products to get started!</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Failed to load products:', error);
                productsGrid.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-exclamation-triangle"></i>
                        <h3>Error loading products</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }

        function filterProducts() {
            const searchTerm = document.getElementById('productSearch').value.toLowerCase();
            const categoryFilter = document.getElementById('categoryFilter').value;
            const stockFilter = document.getElementById('stockFilter').value;

            filteredProducts = allProducts.filter(product => {
                const matchesSearch = product.name.toLowerCase().includes(searchTerm) ||
                                     (product.description && product.description.toLowerCase().includes(searchTerm));
                
                const matchesCategory = !categoryFilter || 
                                       (product.category && (product.category._id === categoryFilter || product.category === categoryFilter));
                
                let matchesStock = true;
                if (stockFilter === 'in-stock') {
                    matchesStock = product.stock > 10;
                } else if (stockFilter === 'low-stock') {
                    matchesStock = product.stock > 0 && product.stock <= 10;
                } else if (stockFilter === 'out-of-stock') {
                    matchesStock = product.stock === 0;
                }

                return matchesSearch && matchesCategory && matchesStock;
            });

            currentPage = 1;
            renderProducts();
        }

        function renderProducts() {
            const productsGrid = document.getElementById('productsGrid');
            
            if (filteredProducts.length === 0) {
                productsGrid.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-search"></i>
                        <h3>No products found</h3>
                        <p>Try adjusting your search criteria.</p>
                    </div>
                `;
                return;
            }

            const startIndex = (currentPage - 1) * productsPerPage;
            const endIndex = startIndex + productsPerPage;
            const productsToShow = filteredProducts.slice(startIndex, endIndex);

            productsGrid.innerHTML = productsToShow.map(product => createProductCard(product)).join('');
            renderPagination();
        }

        function createProductCard(product) {
            const categoryName = product.category ? (product.category.name || product.category) : 'Uncategorized';
            const stockStatus = product.stock === 0 ? 'Out of Stock' : 
                               product.stock <= 10 ? 'Low Stock' : 'In Stock';
            const stockClass = product.stock === 0 ? 'danger' : 
                              product.stock <= 10 ? 'warning' : 'success';

            return `
                <div class="product-card">
                    <div class="product-header">
                        <div class="product-info">
                            <h3>${escapeHtml(product.name)}</h3>
                            <span class="product-category">${escapeHtml(categoryName)}</span>
                        </div>
                        <div class="product-status">
                            <span class="btn btn-small btn-${stockClass}">${stockStatus}</span>
                        </div>
                    </div>
                    
                    <div class="product-details">
                        <div class="product-detail">
                            <span class="label">Price:</span>
                            <span class="value">â‚¹${product.price ? product.price.toLocaleString() : '0'}</span>
                        </div>
                        <div class="product-detail">
                            <span class="label">Stock:</span>
                            <span class="value">${product.stock || 0} ${product.unit || 'pieces'}</span>
                        </div>
                        ${product.brand ? `
                        <div class="product-detail">
                            <span class="label">Brand:</span>
                            <span class="value">${escapeHtml(product.brand)}</span>
                        </div>
                        ` : ''}
                        <div class="product-detail">
                            <span class="label">Added:</span>
                            <span class="value">${new Date(product.createdAt || Date.now()).toLocaleDateString()}</span>
                        </div>
                    </div>
                    
                    <div class="product-actions">
                        <button class="btn btn-small btn-warning" onclick="editProduct('${product._id || product.id}')">
                            <i class="fas fa-edit"></i> Edit
                        </button>
                        <button class="btn btn-small btn-danger" onclick="confirmDeleteProduct('${product._id || product.id}', '${escapeHtml(product.name)}')">
                            <i class="fas fa-trash"></i> Delete
                        </button>
                        <a href="marketplace.html" class="btn btn-small btn-secondary" target="_blank">
                            <i class="fas fa-eye"></i> View
                        </a>
                    </div>
                </div>
            `;
        }

        function renderPagination() {
            const paginationContainer = document.getElementById('productsPagination');
            const totalPages = Math.ceil(filteredProducts.length / productsPerPage);
            
            if (totalPages <= 1) {
                paginationContainer.innerHTML = '';
                return;
            }

            let paginationHtml = '';
            
            paginationHtml += `<button ${currentPage === 1 ? 'disabled' : ''} onclick="changePage(${currentPage - 1})">
                <i class="fas fa-chevron-left"></i>
            </button>`;

            for (let i = 1; i <= totalPages; i++) {
                if (i === 1 || i === totalPages || (i >= currentPage - 2 && i <= currentPage + 2)) {
                    paginationHtml += `<button class="${i === currentPage ? 'active' : ''}" onclick="changePage(${i})">${i}</button>`;
                } else if (i === currentPage - 3 || i === currentPage + 3) {
                    paginationHtml += '<button disabled>...</button>';
                }
            }

            paginationHtml += `<button ${currentPage === totalPages ? 'disabled' : ''} onclick="changePage(${currentPage + 1})">
                <i class="fas fa-chevron-right"></i>
            </button>`;

            paginationContainer.innerHTML = paginationHtml;
        }

        function changePage(page) {
            const totalPages = Math.ceil(filteredProducts.length / productsPerPage);
            if (page < 1 || page > totalPages) return;
            
            currentPage = page;
            renderProducts();
            
            document.getElementById('productsGrid').scrollIntoView({ behavior: 'smooth' });
        }

        function setupCategorySelection() {
            const categoryItems = document.querySelectorAll('.category-item');
            const categoryInput = document.getElementById('category');

            categoryItems.forEach(item => {
                item.addEventListener('click', () => {
                    categoryItems.forEach(i => i.classList.remove('selected'));
                    item.classList.add('selected');
                    selectedCategory = item.dataset.categoryId;
                    categoryInput.value = selectedCategory;
                    console.log('Selected category ID:', selectedCategory);
                });
            });
        }

        function setupImageUpload() {
            const imageInput = document.getElementById('images');
            const imagePreview = document.getElementById('imagePreview');

            imageInput.addEventListener('change', function(e) {
                const files = Array.from(e.target.files);
                if (files.length > 5) {
                    showAlert('You can upload maximum 5 images', 'error');
                    return;
                }

                selectedFiles = files;
                displayImagePreviews(files);
            });
        }

        function displayImagePreviews(files) {
            const imagePreview = document.getElementById('imagePreview');
            imagePreview.innerHTML = '';

            files.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const div = document.createElement('div');
                    div.className = 'image-preview-item';
                    div.innerHTML = `
                        <img src="${e.target.result}" alt="Preview ${index + 1}">
                        <button type="button" class="image-remove" onclick="removeImage(${index})">
                            <i class="fas fa-times"></i>
                        </button>
                    `;
                    imagePreview.appendChild(div);
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            selectedFiles.splice(index, 1);
            displayImagePreviews(selectedFiles);
            
            const dt = new DataTransfer();
            selectedFiles.forEach(file => dt.items.add(file));
            document.getElementById('images').files = dt.files;
        }

        function setupForm() {
            const form = document.getElementById('productForm');
            form.addEventListener('submit', handleFormSubmit);
        }
        
        // --- START OF FIXED FUNCTION ---
        async function handleFormSubmit(e) {
            e.preventDefault();
            
            // DEV HACK: Temporarily allow adding without login
            // if (!window.HybridAuthClient || !window.HybridAuthClient.getCurrentUser()) {
            //     showAlert('You must be logged in to add/update products.', 'error');
            //     return;
            // }

            if (!selectedCategory) {
                showAlert('Please select a category', 'error');
                return;
            }

            const form = e.target;
            const isEditing = form.dataset.editingId;
            
            const formData = new FormData();
            
            formData.append('name', document.getElementById('name').value);
            formData.append('description', document.getElementById('description').value);
            formData.append('price', document.getElementById('price').value);
            formData.append('category', selectedCategory);
            formData.append('stock', document.getElementById('stock').value);
            formData.append('unit', document.getElementById('unit').value);
            
            const originalPrice = document.getElementById('originalPrice').value;
            if (originalPrice) {
                const price = parseFloat(document.getElementById('price').value);
                const original = parseFloat(originalPrice);
                if (original > price) {
                    const discountPercentage = ((original - price) / original) * 100;
                    formData.append('discountPercentage', discountPercentage.toFixed(2));
                }
            }
            
            const brand = document.getElementById('brand').value;
            if (brand) formData.append('brand', brand);
            
            const weight = document.getElementById('weight').value;
            if (weight) formData.append('weight', weight);
            
            const tags = document.getElementById('tags').value;
            if (tags) formData.append('tags', tags);

            selectedFiles.forEach(file => {
                formData.append('images', file);
            });

            console.log('=== FORM DATA BEING SENT ===');
            for (let pair of formData.entries()) {
                console.log(pair[0] + ': ' + (pair[1] instanceof File ? `[File: ${pair[1].name}]` : pair[1]));
            }

            showLoading(true);
            document.querySelector('#loading p').textContent = isEditing ? 
                'Updating your product...' : 'Adding your product to QuickLocal...';

            try {
                const endpoint = isEditing ? `products/${isEditing}` : 'products';
                const method = isEditing ? 'PUT' : 'POST';

                // FIXED: Use HybridAuthClient.apiCall
                // It does NOT need the full URL, and it handles auth automatically.
                // We MUST undefine Content-Type for FormData to work correctly.
                const response = await window.HybridAuthClient.apiCall(endpoint, {
                    method: method,
                    body: formData
                    // HEADERS REMOVED. The browser will now
                    // correctly set the 'multipart/form-data' header.
                });

                const result = await response.json();

                if (result.success || response.ok) {
                    const action = isEditing ? 'updated' : 'added';
                    showAlert(`Product ${action} successfully! ðŸŽ‰`, 'success');
                    
                    resetForm();
                    delete form.dataset.editingId;
                    
                    document.querySelector('#productForm button[type="submit"]').innerHTML = 
                        '<i class="fas fa-plus"></i> Add Product';
                    
                    const editingAlert = document.querySelector('#add-product .alert-warning');
                    if (editingAlert) editingAlert.remove();
                    
                    if (document.getElementById('manage-products').classList.contains('active')) {
                        loadAllProducts();
                    }
                } else {
                    let errorMessage = result.message || result.error || `Failed to ${isEditing ? 'update' : 'add'} product.`;
                    
                    if (result.errors) { // Handle validation errors
                        const errorList = result.errors.map(err => `â€¢ ${err.msg || err.message || err}`).join('\n');
                        errorMessage += '\n\nValidation Errors:\n' + errorList;
                    }
                    if (result.details) { // Handle validation errors (alternative format)
                        const detailList = result.details.map(d => `â€¢ ${d.msg || d.message || d}`).join('\n');
                        errorMessage += '\n\nDetails:\n' + detailList;
                    }

                    console.error('=== FULL ERROR DETAILS ===');
                    console.error(JSON.stringify(result, null, 2));
                    
                    throw new Error(errorMessage);
                }

            } catch (error) {
                console.error('=== FULL ERROR OBJECT ===');
                console.error(error);
                
                const errorDetails = document.createElement('div');
                errorDetails.className = 'debug-info';
                errorDetails.innerHTML = `
                    <strong>Debug Information:</strong><br>
                    ${error.message.replace(/\n/g, '<br>')}
                `;
                
                const action = isEditing ? 'update' : 'add';
                showAlert(`Failed to ${action} product. See details below.`, 'error');
                document.getElementById('alertContainer').appendChild(errorDetails);
            } finally {
                showLoading(false);
            }
        }
        // --- END OF FIXED FUNCTION ---

        function resetForm() {
            document.getElementById('productForm').reset();
            document.querySelectorAll('.category-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.getElementById('imagePreview').innerHTML = '';
            selectedCategory = '';
            selectedFiles = [];
            
            // Reset editing state
            const form = document.getElementById('productForm');
            delete form.dataset.editingId;
            document.querySelector('#productForm button[type="submit"]').innerHTML = 
                '<i class="fas fa-plus"></i> Add Product';
            const editingAlert = document.querySelector('#add-product .alert-warning');
            if (editingAlert) editingAlert.remove();
        }
        
        // --- START: ADDED HEALTH CHECK FUNCTION ---
        async function checkServerHealth() {
            try {
                const response = await window.HybridAuthClient.apiCall('health', {
                    method: 'GET'
                    // You might want to add a timeout if your HybridAuthClient supports it
                });
                
                if (!response.ok) {
                   const data = await response.json();
                   throw new Error(data.status || 'Server not healthy');
                }
                
                console.log('Server health OK');
                return true;
            } catch (error) {
                console.warn('Server health check failed:', error);
                return false;
            }
        }
        
        // --- START: UPDATED CONFIRM DELETE FUNCTION ---
        async function confirmDeleteProduct(productId, productName) {
            const isServerHealthy = await checkServerHealth();
            
            if (!isServerHealthy) {
                showAlert('Server is currently unavailable or unhealthy. Please try again in a few moments.', 'error');
                return;
            }
            
            showModal(
                'Delete Product',
                `Are you sure you want to delete "${productName}"? This action cannot be undone.`,
                () => deleteProduct(productId)
            );
        }
        // --- END: UPDATED CONF lf/1024 / 1024),
        heapTotal: Math.round(mem.heapTotal / 1024 / 1024),
        heapUsed: Math.round(mem.heapUsed / 1024 / 1024),
        external: Math.round(mem.external / 1024 / 1024),
        arrayBuffers: Math.round((mem.arrayBuffers || 0) / 1024 / 1024)
      };
      
      // Memory health indicators
      const heapUsagePercent = Math.round((mem.heapUsed / mem.heapTotal) * 100);
      const isHealthy = memoryMB.rss < 400 && heapUsagePercent < 80; // Render free tier ~512MB
      const alertLevel = memoryMB.rss > 450 ? 'critical' : memoryMB.rss > 350 ? 'warning' : 'normal';
      
      res.json({
        timestamp: new Date().toISOString(),
        memoryMB,
        heapUsagePercent,
        isHealthy,
        alertLevel,
        uptime: Math.floor(process.uptime()),
        // Additional context
        nodeVersion: process.version,
        platform: process.platform,
        pid: process.pid,
        // Render-specific info
        renderMemoryLimit: '512MB (free tier)',
        recommendations: isHealthy ? [] : this.getMemoryRecommendations(memoryMB, heapUsagePercent)
      });
    });
    
    // Metrics endpoint (enhanced with memory focus)
    if (this.config.ENABLE_METRICS) {
      this.app.get('/metrics', (req, res) => {
        const mem = process.memoryUsage();
        res.set('Content-Type', 'text/plain');
        res.send(`# HELP process_memory_rss_bytes Resident set size in bytes
# TYPE process_memory_rss_bytes gauge
process_memory_rss_bytes ${mem.rss}
# HELP process_memory_heap_used_bytes Heap used in bytes
# TYPE process_memory_heap_used_bytes gauge
process_memory_heap_used_bytes ${mem.heapUsed}
# HELP server_uptime_seconds Server uptime in seconds
# TYPE server_uptime_seconds counter
server_uptime_seconds ${Math.floor(process.uptime())}`);
      });

      this.app.get('/metrics/summary', (req, res) => {
        const mem = process.memoryUsage();
        res.json({
          uptime: Math.floor(process.uptime()),
          memory: {
            rss: Math.round(mem.rss / 1024 / 1024) + 'MB',
            heapUsed: Math.round(mem.heapUsed / 1024 / 1024) + 'MB',
            heapTotal: Math.round(mem.heapTotal / 1024 / 1024) + 'MB',
            external: Math.round(mem.external / 1024 / 1024) + 'MB'
          },
          cpu: process.cpuUsage(),
          platform: process.platform,
          nodeVersion: process.version
        });
      });
    }

    // Server info endpoint
    this.app.get('/api/v1/info', (req, res) => {
      res.json({
        name: this.config.APP_NAME,
        version: this.config.APP_VERSION,
        status: 'operational',
        timestamp: new Date().toISOString(),
        environment: this.config.NODE_ENV,
        instance_id: this.config.INSTANCE_ID,
        api_version: this.config.API_VERSION,
        timezone: process.env.TIMEZONE || 'UTC',
        currency: process.env.CURRENCY || 'USD',
        server: {
          uptime: Math.floor(process.uptime()),
          memory: process.memoryUsage(),
          node_version: process.version,
          platform: process.platform,
          cpu_count: os.cpus().length,
          load_average: os.loadavg()
        },
        features: {
          websockets: !!this.io,
          clustering: this.config.CLUSTER_MODE,
          metrics: this.config.ENABLE_METRICS,
          caching: this.config.ENABLE_CACHING,
          compression: this.config.COMPRESSION_ENABLED,
          rate_limiting: this.config.RATE_LIMIT_ENABLED,
          brute_force_protection: true,
          reviews: process.env.FEATURE_REVIEWS === 'true',
          wishlist: process.env.FEATURE_WISHLIST === 'true',
          live_tracking: process.env.FEATURE_LIVE_TRACKING === 'true',
          chat: process.env.FEATURE_CHAT === 'true',
          loyalty_program: process.env.FEATURE_LOYALTY_PROGRAM === 'true',
          delivery_system: process.env.DELIVERY_ENABLED === 'true'
        },
        endpoints: this.loadedRoutes ? this.loadedRoutes.reduce((acc, route) => {
          acc[route.name.toLowerCase().replace(/\s+/g, '_')] = route.path;
          return acc;
        }, {}) : {},
        marketplace: {
          min_order_amount: process.env.MIN_ORDER_AMOUNT || 50,
          max_order_amount: process.env.MAX_ORDER_AMOUNT || 50000,
          delivery_fee: process.env.BASE_DELIVERY_FEE || 25,
          free_delivery_threshold: process.env.FREE_DELIVERY_THRESHOLD || 500,
          platform_commission: process.env.PLATFORM_COMMISSION || 0.025
        },
        documentation: {
          health_check: '/health',
          metrics: '/metrics',
          api_docs: '/api/v1/docs',
          rate_limits: {
            general: `${this.config.RATE_LIMIT_MAX} requests per ${this.config.RATE_LIMIT_WINDOW / 60000} minutes`,
            auth: `${this.config.AUTH_RATE_LIMIT_MAX} requests per 15 minutes`,
            orders: `${this.config.ORDER_RATE_LIMIT_MAX} requests per minute`
          }
        }
      });
    });
    
    // API documentation endpoint
    if (this.config.ENABLE_API_DOCS) {
      this.app.get('/api/v1/docs', (req, res) => {
        res.json({
          title: `${this.config.APP_NAME} API Documentation`,
          version: this.config.API_VERSION,
          description: 'Complete e-commerce marketplace API with real-time features',
          base_url: `${req.protocol}://${req.get('host')}${this.config.API_BASE_PATH}`,
          instance_id: this.config.INSTANCE_ID,
          authentication: {
            type: 'Bearer Token',
            header: 'Authorization',
            format: 'Bearer <token>',
            refresh_token: 'Supported',
            expires_in: process.env.JWT_ACCESS_EXPIRES || '24h'
          },
          endpoints: this.loadedRoutes ? this.loadedRoutes.map(route => ({
            name: route.name,
            path: route.path,
            priority: route.priority,
            status: route.status
          })) : [],
          features: {
            pagination: 'Supported with limit/offset and cursor-based',
            filtering: 'Advanced filtering with query parameters',
            sorting: 'Multi-field sorting supported',
            search: 'Full-text search available',
            real_time: this.io ? 'WebSocket support for live updates' : 'Not available',
            file_upload: 'Multi-part form data supported',
            webhooks: 'Event-driven notifications supported'
          },
          rate_limits: {
            general: `${this.config.RATE_LIMIT_MAX} requests per ${this.config.RATE_LIMIT_WINDOW / 60000} minutes`,
            auth: `${this.config.AUTH_RATE_LIMIT_MAX} requests per 15 minutes`,
            orders: `${this.config.ORDER_RATE_LIMIT_MAX} requests per minute`
          },
          websocket: this.io ? {
            enabled: true,
            url: `ws://${req.get('host')}`,
            events: [
              'order_status_update',
              'delivery_location_update', 
              'new_message',
              'stock_update',
              'price_change',
              'seller_notification'
            ],
            rooms: [
              'user_{user_id}',
              'order_{order_id}',
              'seller_{seller_id}',
              'product_{product_id}'
            ]
          } : { enabled: false },
          marketplace_features: {
            multi_vendor: true,
            inventory_management: true,
            order_tracking: true,
            review_system: process.env.FEATURE_REVIEWS === 'true',
            wishlist: process.env.FEATURE_WISHLIST === 'true',
            loyalty_program: process.env.FEATURE_LOYALTY_PROGRAM === 'true',
            bulk_orders: process.env.FEATURE_BULK_ORDERS === 'true',
            scheduled_delivery: process.env.FEATURE_SCHEDULED_DELIVERY === 'true'
          }
        });
      });
    }

    // Advanced UX Features API endpoints
    this.setupUXFeaturesEndpoints();
    
    // CORS test endpoint for debugging
    this.app.get('/api/v1/cors-test', (req, res) => {
      console.log(`[CORS TEST] Request from origin: ${req.headers.origin}`);
      res.json({
        success: true,
        message: 'CORS is working!',
        origin: req.headers.origin,
        timestamp: new Date().toISOString(),
        headers: {
          'access-control-allow-origin': res.getHeader('Access-Control-Allow-Origin'),
          'access-control-allow-credentials': res.getHeader('Access-Control-Allow-Credentials')
        }
      });
    });
    
    // Server status endpoint
    this.app.get('/status', (req, res) => {
      res.json({
        status: 'operational',
        timestamp: new Date().toISOString(),
        uptime: process.uptime(),
        memory: process.memoryUsage(),
        cpu: process.cpuUsage(),
        connections: this.server.listening ? 'accepting' : 'not accepting',
        socket_connections: this.io ? this.io.engine.clientsCount : 0,
        environment: this.config.NODE_ENV,
        version: this.config.APP_VERSION,
        cors_config: {
          allowed_origins: CORSManager.getOrigins(),
          frontend_urls: process.env.FRONTEND_URLS?.split(','),
          client_url: process.env.CLIENT_URL
        }
      });
    });
  }

  setupUXFeaturesEndpoints() {
    // Recently viewed products endpoint
    this.app.post('/api/v1/user/recently-viewed', async (req, res) => {
      try {
        const { productId } = req.body;
        const userId = req.user?.id;
        
        if (!productId) {
          return res.status(400).json({
            success: false,
            error: 'Product ID required'
          });
        }

        // If user is logged in, store in database
        if (userId) {
          try {
            const User = mongoose.model('User');
            await User.findByIdAndUpdate(
              userId,
              {
                $pull: { recentlyViewed: productId },
                $push: {
                  recentlyViewed: {
                    $each: [{ productId, viewedAt: new Date() }],
                    $position: 0,
                    $slice: 20 // Keep only last 20 items
                  }
                }
              },
              { upsert: false }
            );
          } catch (error) {
            console.warn('Failed to save recently viewed to database:', error);
          }
        }

        res.json({
          success: true,
          message: 'Product view tracked'
        });
      } catch (error) {
        console.error('Recently viewed tracking error:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to track product view',
          message: error.message
        });
      }
    });

    // Get recently viewed products
    this.app.get('/api/v1/user/recently-viewed', async (req, res) => {
      try {
        const userId = req.user?.id;
        const limit = parseInt(req.query.limit) || 10;
        
        if (!userId) {
          return res.json({
            success: true,
            products: []
          });
        }

        const User = mongoose.model('User');
        const Product = mongoose.model('Product');
        
        const user = await User.findById(userId)
          .select('recentlyViewed')
          .lean();
        
        if (!user?.recentlyViewed?.length) {
          return res.json({
            success: true,
            products: []
          });
        }

        const productIds = user.recentlyViewed
          .slice(0, limit)
          .map(item => item.productId);
        
        const products = await Product.find({
          _id: { $in: productIds },
          isDeleted: { $ne: true }
        })
        .select('name price images averageRating reviewCount stock')
        .lean();

        // Maintain order from recently viewed
        const orderedProducts = productIds
          .map(id => products.find(p => p._id.toString() === id.toString()))
          .filter(Boolean);

        res.json({
          success: true,
          products: orderedProducts
        });
      } catch (error) {
        console.error('Get recently viewed error:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to get recently viewed products',
          message: error.message
        });
      }
    });

    // Product comparison endpoints
    this.app.post('/api/v1/products/compare', async (req, res) => {
      try {
        const { productIds } = req.body;
        
        if (!productIds || !Array.isArray(productIds) || productIds.length === 0) {
          return res.status(400).json({
            success: false,
            error: 'Product IDs array required'
          });
        }

        if (productIds.length > 5) {
          return res.status(400).json({
            success: false,
            error: 'Maximum 5 products can be compared'
          });
        }

        const Product = mongoose.model('Product');
        const products = await Product.find({
          _id: { $in: productIds },
          isDeleted: { $ne: true }
        })
        .select('name brand price originalPrice images averageRating reviewCount stock specifications category')
        .lean();

        // Generate comparison data
        const comparison = {
          products,
          comparisonTable: this.generateComparisonTable(products),
          summary: this.generateComparisonSummary(products)
        };

        res.json({
          success: true,
          comparison
        });
      } catch (error) {
        console.error('Product comparison error:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to compare products',
          message: error.message
        });
      }
    });

    // Quick view endpoint (enhanced product details)
    this.app.get('/api/v1/products/:id/quickview', async (req, res) => {
      try {
        const { id } = req.params;
        const userId = req.user?.id;
        
        const Product = mongoose.model('Product');
        const product = await Product.findById(id)
          .populate('sellerId', 'businessName verified')
          .lean();

        if (!product || product.isDeleted) {
          return res.status(404).json({
            success: false,
            error: 'Product not found'
          });
        }

        // Check if in user's wishlist
        let inWishlist = false;
        if (userId) {
          try {
            const User = mongoose.model('User');
            const user = await User.findById(userId).select('wishlist').lean();
            inWishlist = user?.wishlist?.some(item => item.toString() === id);
          } catch (error) {
            console.warn('Failed to check wishlist status:', error);
          }
        }

        res.json({
          success: true,
          product: {
            ...product,
            inWishlist
          }
        });
      } catch (error) {
        console.error('Quick view error:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to get product details',
          message: error.message
        });
      }
    });

    // Product recommendations endpoint
    this.app.get('/api/v1/products/:id/recommendations', async (req, res) => {
      try {
        const { id } = req.params;
        const limit = parseInt(req.query.limit) || 10;
        const userId = req.user?.id;
        
        const Product = mongoose.model('Product');
        const currentProduct = await Product.findById(id).select('category brand tags').lean();
        
        if (!currentProduct) {
          return res.status(404).json({
            success: false,
            error: 'Product not found'
          });
        }

        // Build recommendation query
        const recommendationQuery = {
          _id: { $ne: id },
          isDeleted: { $ne: true },
          stock: { $gt: 0 },
          $or: [
            { category: currentProduct.category },
            { brand: currentProduct.brand },
            { tags: { $in: currentProduct.tags || [] } }
          ]
        };

        const recommendations = await Product.find(recommendationQuery)
          .select('name price originalPrice images averageRating reviewCount stock')
          .sort({ averageRating: -1, reviewCount: -1 })
          .limit(limit)
          .lean();

        res.json({
          success: true,
          recommendations
        });
      } catch (error) {
        console.error('Product recommendations error:', error);
        res.status(500).json({
          success: false,
          error: 'Failed to get product recommendations',
          message: error.message
        });
      }
    });

    console.log('âœ¨ UX Features API endpoints initialized');
  }

  generateComparisonTable(products) {
    if (!products.length) return {};

    const comparisonFields = ['price', 'originalPrice', 'brand', 'averageRating', 'reviewCount', 'stock'];
    const specificationFields = new Set();
    
    // Collect all specification keys
    products.forEach(product => {
      if (product.specifications) {
        Object.keys(product.specifications).forEach(key => {
          specificationFields.add(key);
        });
      }
    });

    const comparison = {};
    
    // Basic fields
    comparisonFields.forEach(field => {
      comparison[field] = products.map(product => product[field] || 'N/A');
    });
    
    // Specifications
    Array.from(specificationFields).forEach(spec => {
      comparison[spec] = products.map(product => 
        product.specifications?.[spec] || 'N/A'
      );
    });

    return comparison;
  }

  generateComparisonSummary(products) {
    if (!products.length) return {};

    const summary = {
      cheapest: null,
      mostExpensive: null,
      bestRated: null,
      mostReviewed: null
    };

    let minPrice = Infinity;
    let maxPrice = 0;
    let maxRating = 0;
    let maxReviews = 0;

    products.forEach(product => {
      if (product.price < minPrice) {
        minPrice = product.price;
        summary.cheapest = product;
      }
      
      if (product.price > maxPrice) {
        maxPrice = product.price;
        summary.mostExpensive = product;
      }
      
      if ((product.averageRating || 0) > maxRating) {
        maxRating = product.averageRating || 0;
        summary.bestRated = product;
      }
      
      if ((product.reviewCount || 0) > maxReviews) {
        maxReviews = product.reviewCount || 0;
        summary.mostReviewed = product;
      }
    });

    return summary;
  }

  async checkDatabase() {
    try {
      if (mongoose.connection.readyState !== 1) {
        return { status: 'critical', message: 'Database disconnected' };
      }

      const startTime = Date.now();
      await mongoose.connection.db.admin().ping();
      const responseTime = Date.now() - startTime;

      return {
        status: responseTime < 1000 ? 'healthy' : 'degraded',
        response_time: responseTime,
        connection_state: mongoose.connection.readyState,
        database_name: mongoose.connection.db?.databaseName,
        host: mongoose.connection.host
      };
    } catch (error) {
      return {
        status: 'critical',
        message: error.message,
        error: 'Database health check failed'
      };
    }
  }

  checkMemory() {
    const memUsage = process.memoryUsage();
    const totalMem = os.totalmem();
    const freeMem = os.freemem();
    const usagePercent = (memUsage.heapUsed / memUsage.heapTotal) * 100;
    const systemUsagePercent = ((totalMem - freeMem) / totalMem) * 100;
    
    return {
      status: usagePercent > 90 || systemUsagePercent > 95 ? 'critical' : 
              usagePercent > 75 || systemUsagePercent > 85 ? 'degraded' : 'healthy',
      heap_used: memUsage.heapUsed,
      heap_total: memUsage.heapTotal,
      usage_percent: Math.round(usagePercent),
      system_usage_percent: Math.round(systemUsagePercent),
      external: memUsage.external,
      rss: memUsage.rss,
      free_memory: freeMem,
      total_memory: totalMem
    };
  }

  checkDisk() {
    try {
      const stats = fs.statSync(__dirname);
      const logStats = fs.statSync(this.config.LOG_DIR);
      
      return {
        status: 'healthy',
        accessible: true,
        log_directory: {
          accessible: true,
          path: this.config.LOG_DIR
        }
      };
    } catch (error) {
      return {
        status: 'critical',
        message: 'Disk access failed',
        error: error.message
      };
    }
  }

  async checkExternalServices() {
    const services = [];
    
    try {
      // Check payment gateways
      if (process.env.RAZORPAY_ENABLED === 'true') {
        services.push({
          name: 'razorpay',
          status: 'configured',
          enabled: true
        });
      }

      if (process.env.STRIPE_ENABLED === 'true') {
        services.push({
          name: 'stripe',
          status: 'configured',
          enabled: true
        });
      }

      // Check email service
      if (process.env.ENABLE_EMAIL_NOTIFICATIONS === 'true') {
        services.push({
          name: 'email_service',
          status: process.env.SMTP_HOST ? 'configured' : 'not_configured',
          provider: 'smtp'
        });
      }

      // Check file storage
      if (process.env.CLOUDINARY_CLOUD_NAME) {
        services.push({
          name: 'cloudinary',
          status: 'configured',
          enabled: true
        });
      }

    } catch (error) {
      console.warn('External service health check failed:', error.message);
    }

    return {
      status: services.length > 0 ? 'healthy' : 'degraded',
      services,
      total_services: services.length
    };
  }

  checkFeatures() {
    return {
      status: 'healthy',
      enabled_features: {
        reviews: process.env.FEATURE_REVIEWS === 'true',
        ratings: process.env.FEATURE_RATINGS === 'true',
        wishlist: process.env.FEATURE_WISHLIST === 'true',
        live_tracking: process.env.FEATURE_LIVE_TRACKING === 'true',
        chat: process.env.FEATURE_CHAT === 'true',
        multiple_addresses: process.env.FEATURE_MULTIPLE_ADDRESSES === 'true',
        scheduled_delivery: process.env.FEATURE_SCHEDULED_DELIVERY === 'true',
        loyalty_program: process.env.FEATURE_LOYALTY_PROGRAM === 'true',
        referral_program: process.env.FEATURE_REFERRAL_PROGRAM === 'true',
        bulk_orders: process.env.FEATURE_BULK_ORDERS === 'true'
      },
      notifications: {
        push: process.env.ENABLE_PUSH_NOTIFICATIONS === 'true',
        sms: process.env.ENABLE_SMS_NOTIFICATIONS === 'true',
        in_app: process.env.ENABLE_IN_APP_NOTIFICATIONS === 'true',
        email: process.env.ENABLE_EMAIL_NOTIFICATIONS === 'true'
      }
    };
  }

  getPaymentGatewayStatus() {
    return {
      razorpay: {
        enabled: process.env.RAZORPAY_ENABLED === 'true',
        configured: !!(process.env.RAZORPAY_KEY_ID && process.env.RAZORPAY_KEY_SECRET)
      },
      stripe: {
        enabled: process.env.STRIPE_ENABLED === 'true',
        configured: !!(process.env.STRIPE_PUBLISHABLE_KEY && process.env.STRIPE_SECRET_KEY)
      },
      paypal: {
        enabled: process.env.PAYPAL_ENABLED === 'true',
        configured: !!(process.env.PAYPAL_CLIENT_ID && process.env.PAYPAL_CLIENT_SECRET)
      }
    };
  }

  setupErrorHandling() {
    // Shutdown middleware
    this.app.use((req, res, next) => {
      if (this.isShuttingDown) {
        res.status(530).json({
          error: 'Server shutting down',
          message: 'Server is currently shutting down. Please try again in a few moments.',
          correlation_id: req.correlationId
        });
        return;
      }
      next();
    });

    // 404 handler with intelligent suggestions
    this.app.use('*', (req, res) => {
      const availableRoutes = this.loadedRoutes ? this.loadedRoutes.map(route => route.path) : [];
      const method = req.method;
      const requestedPath = req.originalUrl;
      
      // Find similar routes using basic string matching
      const suggestions = availableRoutes
        .filter(route => {
          const similarity = this.calculateSimilarity(requestedPath, route);
          return similarity > 0.3;
        })
        .slice(0, 3);

      console.warn(`404: ${method} ${requestedPath} from ${req.headers.origin || 'unknown'} [${req.correlationId}]`);
      
      res.status(404).json({
        error: 'Endpoint not found',
        message: `${method} ${requestedPath} does not exist on this server`,
        correlation_id: req.correlationId,
        instance_id: this.config.INSTANCE_ID,
        timestamp: new Date().toISOString(),
        suggestions: {
          documentation: {
            api_docs: '/api/v1/docs',
            health_check: '/health',
            server_status: '/status'
          },
          similar_routes: suggestions,
          available_methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
          api_version: `Current API version is ${this.config.API_VERSION}`,
          base_path: this.config.API_BASE_PATH
        },
        help: {
          documentation_url: `${req.protocol}://${req.get('host')}/api/v1/docs`,
          support_contact: process.env.EMAIL_FROM || 'support@quicklocal.com'
        }
      });
    });

    // Enhanced global error handler
    this.app.use((err, req, res, next) => {
      const errorId = `${this.config.INSTANCE_ID}-${Date.now().toString(36)}-${Math.random().toString(36).substr(2)}`;
      
      // Enhanced error logging
      const errorLog = {
        error_id: errorId,
        error: err.message,
        name: err.name,
        stack: this.config.IS_PRODUCTION ? undefined : err.stack,
        url: req.originalUrl,
        method: req.method,
        ip: req.ip,
        user_agent: req.headers['user-agent'],
        correlation_id: req.correlationId,
        user_id: req.user?.id || null,
        timestamp: new Date().toISOString(),
        environment: this.config.NODE_ENV,
        instance_id: this.config.INSTANCE_ID
      };

      console.error(`Unhandled error [${errorId}]:`, errorLog);

      // Enhanced error type handling
      let statusCode = err.status || err.statusCode || 500;
      let message = err.message;
      let errorType = 'internal_server_error';
      let helpMessage = null;

      // Mongoose/MongoDB errors
      if (err.name === 'ValidationError') {
        statusCode = 400;
        message = 'Validation failed';
        errorType = 'validation_error';
        helpMessage = 'Please check your input data and try again';
      } else if (err.name === 'CastError') {
        statusCode = 400;
        message = 'Invalid ID format';
        errorType = 'cast_error';
        helpMessage = 'Please provide a valid MongoDB ObjectId';
      } else if (err.code === 11000) {
        statusCode = 409;
        message = 'Duplicate entry';
        errorType = 'duplicate_error';
        helpMessage = 'This record already exists';
      } else if (err.name === 'MongooseError' || err.name === 'MongoError') {
        statusCode = 500;
        message = 'Database error';
        errorType = 'database_error';
        helpMessage = 'Please try again later';
      }

      // JWT errors
      else if (err.name === 'JsonWebTokenError') {
        statusCode = 401;
        message = 'Invalid token';
        errorType = 'jwt_error';
        helpMessage = 'Please provide a valid authentication token';
      } else if (err.name === 'TokenExpiredError') {
        statusCode = 401;
        message = 'Token expired';
        errorType = 'token_expired';
        helpMessage = 'Please refresh your authentication token';
      }

      // Express errors
      else if (err.type === 'entity.parse.failed') {
        statusCode = 400;
        message = 'Invalid JSON';
        errorType = 'json_parse_error';
        helpMessage = 'Please check your JSON syntax';
      } else if (err.type === 'entity.too.large') {
        statusCode = 413;
        message = 'Request too large';
        errorType = 'payload_too_large';
        helpMessage = `Maximum request size is ${this.config.MAX_REQUEST_SIZE}`;
      }

      // Multer errors (file upload)
      else if (err.code === 'LIMIT_FILE_SIZE') {
        statusCode = 413;
        message = 'File too large';
        errorType = 'file_too_large';
        helpMessage = `Maximum file size is ${Math.round(this.config.MAX_FILE_SIZE / 1024 / 1024)}MB`;
      }

      const errorResponse = {
        error: this.config.IS_PRODUCTION && statusCode === 500 ? 'Internal Server Error' : message,
        error_id: errorId,
        error_type: errorType,
        correlation_id: req.correlationId,
        instance_id: this.config.INSTANCE_ID,
        timestamp: new Date().toISOString(),
        path: req.originalUrl,
        method: req.method,
        ...(helpMessage && { help: helpMessage }),
        ...(this.config.IS_PRODUCTION ? {} : { 
          stack: err.stack,
          details: err.details || null,
          validation_errors: err.errors || null
        })
      };

      // Add specific help for common errors
      if (statusCode === 401) {
        errorResponse.authentication = {
          required: true,
          header: 'Authorization: Bearer <token>',
        refresh_endpoint: '/api/hybrid-auth/refresh-token'
        };
      } else if (statusCode === 403) {
        errorResponse.authorization = {
          message: 'Insufficient permissions for this resource',
          required_role: err.requiredRole || 'unknown'
        };
      } else if (statusCode === 429) {
        errorResponse.rate_limit = {
          retry_after: err.retryAfter || Math.ceil(this.config.RATE_LIMIT_WINDOW / 1000),
          limit: this.config.RATE_LIMIT_MAX,
          window: this.config.RATE_LIMIT_WINDOW
        };
      }

      res.status(statusCode).json(errorResponse);
    });

    // Global process error handlers
    process.on('uncaughtException', (err) => {
      console.error('ðŸ’¥ Uncaught Exception:', err);
      
      // Give some time for logs to be written, then exit
      setTimeout(() => {
        process.exit(1);
      }, 1000);
    });

    process.on('unhandledRejection', (reason, promise) => {
      console.error('ðŸ’¥ Unhandled Rejection at:', promise, 'reason:', reason);
    });
  }

  // Memory optimization helper
  getMemoryRecommendations(memoryMB, heapUsagePercent) {
    const recommendations = [];
    
    if (memoryMB.rss > 450) {
      recommendations.push('CRITICAL: RSS memory over 450MB - restart recommended');
      recommendations.push('Check for memory leaks in recent deployments');
    } else if (memoryMB.rss > 350) {
      recommendations.push('WARNING: High memory usage - monitor closely');
    }
    
    if (heapUsagePercent > 80) {
      recommendations.push('High heap usage - consider garbage collection');
      recommendations.push('Review recent code changes for memory inefficiencies');
    }
    
    if (memoryMB.external > 50) {
      recommendations.push('High external memory - check file processing operations');
    }
    
    return recommendations;
  }

  calculateSimilarity(str1, str2) {
    const longer = str1.length > str2.length ? str1 : str2;
    const shorter = str1.length > str2.length ? str2 : str1;
    
    if (longer.length === 0) return 1.0;
    
    const editDistance = this.levenshteinDistance(longer, shorter);
    return (longer.length - editDistance) / longer.length;
  }

  levenshteinDistance(str1, str2) {
    const matrix = [];
    
    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }
    
    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }
    
    return matrix[str2.length][str1.length];
  }

  async startServer() {
    return new Promise((resolve, reject) => {
      this.server.listen(this.config.PORT, this.config.HOST, (err) => {
        if (err) {
          reject(err);
          return;
        }

        const serverInfo = `
ðŸŒŸ ${this.config.APP_NAME} E-commerce API Server v${this.config.APP_VERSION}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“‹ Server Configuration:
   ðŸŒ URL: http://${this.config.HOST}:${this.config.PORT}
   ðŸ†” Instance: ${this.config.INSTANCE_ID}
   ðŸ—ï¸  Environment: ${this.config.NODE_ENV}
   ðŸ”§ Node.js: ${process.version}
   ðŸ–¥ï¸  Platform: ${process.platform}
   ðŸ’¾ Memory: ${Math.round(process.memoryUsage().heapUsed / 1024 / 1024)}MB used
   ðŸ”„ Process ID: ${process.pid}
   ðŸŒ Domain: ${this.config.DOMAIN}

ðŸ—„ï¸  Database:
   ðŸ“Š Metrics: /metrics
   ðŸ” API Version: ${this.config.API_VERSION}
   ðŸ“ Routes: ${this.loadedRoutes ? this.loadedRoutes.length : 0} loaded
   ðŸ’° Min Order: â‚¹${process.env.MIN_ORDER_AMOUNT || 50}
   ðŸšš Delivery Fee: â‚¹${process.env.BASE_DELIVERY_FEE || 25}
   ðŸ†“ Free Delivery: â‚¹${process.env.FREE_DELIVERY_THRESHOLD || 500}+

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ¨ ${this.config.APP_NAME} Server is ready to serve customers!
ðŸŒ Visit http://${this.config.HOST}:${this.config.PORT} for API documentation
ðŸª Marketplace ready for ${process.env.CURRENCY || 'INR'} transactions
        `;

        console.log(serverInfo);
        console.log('ðŸš€ QuickLocal API Server started successfully');
        
        // Now show detailed status since everything is actually connected
        console.log('Status: Connected');
        console.log('âœ… Server is connected and running');
        console.log(`ðŸ¦ Database: ${mongoose.connection.db?.databaseName || 'Connected'}`); 
        console.log(`ðŸ–¥ï¸  Host: ${mongoose.connection.host || this.config.HOST}`);
        console.log(`
âš¡ Pool Size: ${process.env.DB_POOL_SIZE || 10}
ðŸ›‘ï¸  Security Features:
ðŸ”’ Helmet Security: ${process.env.HELMET_ENABLED === 'true' ? 'âœ…' : 'âŒ'}
ðŸš¦ Rate Limiting: ${process.env.RATE_LIMIT_ENABLED === 'true' ? 'âœ…' : 'âŒ'} (${process.env.RATE_LIMIT_MAX || 100}/${(process.env.RATE_LIMIT_WINDOW || 900000) / 60000}min)
ðŸ›‘ Brute Force Protection: âœ…
ðŸŒ CORS Origins: ${CORSManager.getOrigins().length} configured
ðŸ” Session Management: âœ…
ðŸ’ª Password Hashing: ${process.env.BCRYPT_SALT_ROUNDS || 12} rounds
ðŸš€ Performance Features:
ðŸ“¦ Compression: ${process.env.COMPRESSION_ENABLED === 'true' ? 'âœ…' : 'âŒ'} (Level: ${process.env.COMPRESSION_LEVEL || 6})
ðŸ“Š Metrics: ${process.env.ENABLE_METRICS === 'true' ? 'âœ…' : 'âŒ'}
ðŸ”Œ Socket.IO: âœ…
âš¡ Circuit Breaker: âœ…
ðŸ• Request Timeout: ${(process.env.REQUEST_TIMEOUT || 30000) / 1000}s
ðŸŽ¯ Clustering: ${process.env.CLUSTER_MODE === 'true' ? 'âœ…' : 'âŒ'}
ðŸ¦ Marketplace Features:
ðŸ’³ Payment Gateways: Multiple enabled
ðŸšš Delivery System: ${process.env.DELIVERY_ENABLED === 'true' ? 'âœ…' : 'âŒ'}
â­ Reviews & Ratings: ${process.env.FEATURE_REVIEWS === 'true' ? 'âœ…' : 'âŒ'}
ðŸ’ Wishlist: ${process.env.FEATURE_WISHLIST === 'true' ? 'âœ…' : 'âŒ'}
ðŸ“ Live Tracking: ${process.env.FEATURE_LIVE_TRACKING === 'true' ? 'âœ…' : 'âŒ'}
ðŸ’¬ Chat System: ${process.env.FEATURE_CHAT === 'true' ? 'âœ…' : 'âŒ'}
ðŸŽ Loyalty Program: ${process.env.FEATURE_LOYALTY_PROGRAM === 'true' ? 'âœ…' : 'âŒ'}
ðŸ“š API Information:
ðŸ“– Documentation: /api/v1/docs
â¤ï¸  Health Check: /health
`);
        
        resolve();
      });

      // Enhanced server error handling
      this.server.on('error', (err) => {
        if (err.code === 'EADDRINUSE') {
          console.error(`âŒ Port ${this.config.PORT} is already in use.`);
          console.log(`ðŸ’¡ Kill existing process: lsof -ti:${this.config.PORT} | xargs kill -9`);
          console.log(`ðŸ’¡ Or try a different port: PORT=10001 npm start`);
        } else if (err.code === 'EACCES') {
          console.error(`âŒ Permission denied for port ${this.config.PORT}.`);
          console.log(`ðŸ’¡ Try a port > 1024 or run with appropriate permissions.`);
        } else if (err.code === 'ENOTFOUND') {
          console.error(`âŒ Host ${this.config.HOST} not found.`);
          console.log(`ðŸ’¡ Check your HOST environment variable.`);
        } else {
          console.error('âŒ Server error:', err);
        }
        
        reject(err);
      });

      // Handle server warnings and client errors
      this.server.on('clientError', (err, socket) => {
        console.warn(`Client error from ${socket.remoteAddress}: ${err.message}`);
        
        if (socket.writable) {
          socket.end('HTTP/1.1 400 Bad Request\r\n\r\n');
        }
      });

      this.server.on('connection', (socket) => {
        socket.on('error', (err) => {
          console.warn(`Socket error: ${err.message}`);
        });
      });
    });
  }

  setupGracefulShutdown() {
    const shutdown = async (signal) => {
      if (this.isShuttingDown) {
        console.warn('âš ï¸ Shutdown already in progress...');
        return;
      }

      this.isShuttingDown = true;
      console.log(`ðŸ›‘ ${signal} received. Starting graceful shutdown...`);

      const shutdownTimeout = setTimeout(() => {
        console.error('âŒ Graceful shutdown timeout exceeded. Forcing exit...');
        process.exit(1);
      }, 30000); // 30 second timeout

      try {
        // Stop accepting new connections
        console.log('ðŸ”„ Stopping HTTP server...');
        await new Promise((resolve, reject) => {
          this.server.close((err) => {
            if (err) reject(err);
            else resolve();
          });
        });

        // Close Socket.IO connections gracefully
        if (this.io) {
          console.log('ðŸ”„ Closing Socket.IO connections...');
          
          // Notify all connected clients about shutdown
          this.io.emit('server_shutdown', {
            message: 'Server is shutting down for maintenance',
            timestamp: new Date().toISOString(),
            reconnect_delay: 5000
          });
          
          // Give clients time to handle the notification
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          this.io.close();
        }

        // Close database connections
        console.log('ðŸ”„ Closing database connections...');
        await mongoose.connection.close();

        // Final cleanup
        console.log('ðŸ”„ Performing final cleanup...');
        
        clearTimeout(shutdownTimeout);
        
        console.log('âœ… Graceful shutdown completed successfully');
        console.log(`ðŸ‘‹ ${this.config.APP_NAME} server stopped cleanly`);
        
        process.exit(0);
      } catch (error) {
        console.error('âŒ Error during graceful shutdown:', error);
        process.exit(1);
      }
    };

    // Handle different shutdown signals
    process.on('SIGTERM', () => shutdown('SIGTERM')); // Docker/PM2 shutdown
    process.on('SIGINT', () => shutdown('SIGINT'));   // Ctrl+C
    process.on('SIGUSR2', () => shutdown('SIGUSR2')); // Nodemon restart
    process.on('SIGHUP', () => shutdown('SIGHUP'));   // Terminal closed

    // Handle PM2 graceful shutdown
    process.on('message', (msg) => {
      if (msg === 'shutdown') {
        shutdown('PM2_SHUTDOWN');
      }
    });
  }

  // Fallback route mounting when main routes fail
  mountFallbackRoutes() {
    const essentialRoutes = [
      // âœ… Using hybrid auth only - legacy auth permanently disabled
      { path: '/api/v1/products', file: './routes/products' },
      { path: '/api/v1/users', file: './routes/users' },
      { path: '/api/v1/orders', file: './routes/orders' },
      { path: '/api/v1/auth', file: './routes/hybridAuth' },
      // FIX: Add the missing notifications route
      { path: '/api/v1/notifications', file: './routes/notifications' }
    ];
    
    essentialRoutes.forEach(route => {
      try {
        const routeHandler = require(route.file);
        this.app.use(route.path, routeHandler);
        console.log(`âœ… Fallback: Mounted ${route.path}`);
      } catch (error) {
        console.error(`âŒ Fallback failed for ${route.path}:`, error.message);
      }
    });
  }
  
  // Emergency route mounting with basic responses
  mountEmergencyRoutes() {
    // Basic hybrid auth route
    this.app.post('/api/v1/auth/login', (req, res) => {
      res.status(503).json({ 
        error: 'Service temporarily unavailable', 
        message: 'Authentication service is being restored' 
      });
    });
    
    // Basic products route
    this.app.get('/api/v1/products', (req, res) => {
      res.status(503).json({ 
        error: 'Service temporarily unavailable', 
        message: 'Product service is being restored',
        products: []
      });
    });
    
    console.log('ðŸš¨ Emergency routes mounted - basic responses active');
  }
}

// Enhanced Cluster Manager for Production Scaling
class QuickLocalClusterManager {
  static start() {
    const config = new QuickLocalConfig().config;
    
    if (config.CLUSTER_MODE && cluster.isPrimary) {
      console.log(`ðŸ”„ Starting QuickLocal in cluster mode with ${config.MAX_WORKERS} workers...`);
      
      // Fork workers
      for (let i = 0; i < config.MAX_WORKERS; i++) {
        const worker = cluster.fork({
          WORKER_ID: i + 1,
          INSTANCE_ID: `${config.INSTANCE_ID}-worker-${i + 1}`
        });
        
        worker.on('message', (message) => {
          if (message.type === 'metrics') {
            // Handle worker metrics in master process
            console.log(`ðŸ“Š Metrics from worker ${worker.id}:`, message.data);
          }
        });
      }

      // Handle worker events
      cluster.on('exit', (worker, code, signal) => {
        const exitCode = worker.process.exitCode;
        console.warn(`âŒ Worker ${worker.process.pid} died with code ${code} and signal ${signal}`);
        
        // Don't restart if it was an intentional shutdown
        if (exitCode !== 0 && signal !== 'SIGTERM' && signal !== 'SIGINT') {
          console.log('ðŸ”„ Starting a new worker to replace the failed one...');
          const newWorker = cluster.fork({
            WORKER_ID: worker.id,
            INSTANCE_ID: `${config.INSTANCE_ID}-worker-${worker.id}`
          });
          
          newWorker.on('message', (message) => {
            if (message.type === 'metrics') {
              console.log(`ðŸ“Š Metrics from replacement worker ${newWorker.id}:`, message.data);
            }
          });
        }
      });

      cluster.on('online', (worker) => {
        console.log(`âœ… Worker ${worker.process.pid} is online (ID: ${worker.id})`);
      });

      cluster.on('listening', (worker, address) => {
        console.log(`ðŸŽ§ Worker ${worker.process.pid} is listening on ${address.address}:${address.port}`);
      });

      // Master process graceful shutdown
      const masterShutdown = () => {
        console.log('ðŸ›‘ Master process shutting down workers...');
        
        const workers = Object.values(cluster.workers);
        let workersShutdown = 0;
        
        // Send shutdown signal to all workers
        workers.forEach(worker => {
          if (worker) {
            worker.send('shutdown');
            
            // Force kill worker after timeout
            setTimeout(() => {
              if (!worker.isDead()) {
                console.warn(`âš ï¸ Force killing worker ${worker.process.pid}`);
                worker.kill('SIGKILL');
              }
            }, 10000);
            
            worker.on('disconnect', () => {
              workersShutdown++;
              if (workersShutdown === workers.length) {
                console.log('âœ… All workers shut down successfully');
                process.exit(0);
              }
            });
          }
        });
        
        // Force exit if workers don't shutdown in time
        setTimeout(() => {
          console.error('âŒ Workers shutdown timeout. Force exiting...');
          process.exit(1);
        }, 15000);
      };

      process.on('SIGTERM', masterShutdown);
      process.on('SIGINT', masterShutdown);

      // Log cluster status every 5 minutes
      setInterval(() => {
        const workers = Object.values(cluster.workers);
        const aliveWorkers = workers.filter(worker => worker && !worker.isDead()).length;
        console.log(`ðŸ“Š Cluster status: ${aliveWorkers}/${config.MAX_WORKERS} workers alive`);
      }, 5 * 60 * 1000);

    } else {
      // Worker process or single process mode
      const server = new QuickLocalServer();
      
      // Handle shutdown message from master
      process.on('message', (msg) => {
        if (msg === 'shutdown') {
          console.log(`ðŸ›‘ Worker ${process.pid} received shutdown signal from master`);
          server.isShuttingDown = true;
          
          // Close server gracefully
          if (server.server) {
            server.server.close(() => {
              process.exit(0);
            });
          } else {
            process.exit(0);
          }
        }
      });
      
      server.initialize().catch((error) => {
        console.error('âŒ Worker startup failed:', error);
        process.exit(1);
      });
    }
  }

  static getClusterInfo() {
    if (cluster.isPrimary) {
      const workers = Object.values(cluster.workers);
      return {
        isPrimary: true,
        totalWorkers: workers.length,
        aliveWorkers: workers.filter(worker => worker && !worker.isDead()).length,
        workers: workers.map(worker => ({
          id: worker.id,
          pid: worker.process.pid,
          state: worker.state,
          isDead: worker.isDead()
        }))
      };
    } else {
      return {
        isPrimary: false,
        workerId: cluster.worker.id,
        pid: process.pid,
        state: cluster.worker.state
      };
    }
  }
}

// Development utilities
class QuickLocalDevUtils {
  static setupDevelopmentTools(app) {
    if (process.env.NODE_ENV !== 'development') return;

    // Development route for testing
    app.get('/dev/test', (req, res) => {
      res.json({
        message: 'Development test endpoint',
        timestamp: new Date().toISOString(),
        environment: process.env.NODE_ENV,
        features: {
          mock_payment: process.env.MOCK_PAYMENT === 'true',
          mock_sms: process.env.MOKC_SMS === 'true',
          mock_email: process.env.MOCK_EMAIL === 'true',
          debug_mode: process.env.DEBUG_MODE === 'true'
        }
      });
    });

    // Route to trigger test events (development only)
    app.post('/dev/trigger/:event', (req, res) => {
      const { event } = req.params;
      const { data } = req.body;

      console.log(`ðŸ§ª Development: Triggering ${event} event`, data);

      // Simulate different events for testing
      switch (event) {
        case 'order_update':
          if (app.io) {
            app.io.to(`order_${data.orderId}`).emit('order_status_update', {
              orderId: data.orderId,
              status: data.status,
              timestamp: new Date().toISOString()
            });
          }
          break;
        case 'delivery_update':
          if (app.io) {
            app.io.to(`order_${data.orderId}`).emit('delivery_location_update', {
              orderId: data.orderId,
              location: data.location,
              timestamp: new Date().toISOString()
            });
          }
          break;
        default:
          return res.status(400).json({ error: 'Unknown event type' });
      }

      res.json({ 
        success: true, 
        message: `${event} event triggered`,
        data 
      });
    });

    console.log('ðŸ§ª Development utilities enabled');
  }

  static logEnvironmentInfo() {
    if (process.env.NODE_ENV !== 'development') return;

    console.log('ðŸ§ª Development Environment Info:');
    console.log(`   Debug Mode: ${process.env.DEBUG_MODE}`);
    console.log(`   Mock Payment: ${process.env.MOCK_PAYMENT}`);
    console.log(`   Mock SMS: ${process.env.MOCK_SMS}`);
    console.log(`   Mock Email: ${process.env.MOCK_EMAIL}`);
    console.log(`   API Docs: ${process.env.ENABLE_API_DOCS}`);
    console.log(`   Seed Data: ${process.env.ENABLE_SEED_DATA}`);
  }
}

// Export everything for use
module.exports = { 
  QuickLocalServer, 
  QuickLocalClusterManager, 
  QuickLocalConfig,
  CORSManager,
  EnhancedSecurityManager,
  QuickLocalRouteManager,
  QuickLocalDevUtils
};

// Start the server if this file is run directly
if (require.main === module) {
  // Log environment info in development
  QuickLocalDevUtils.logEnvironmentInfo();
  
  // Start server (with or without clustering)
  QuickLocalClusterManager.start();
}